<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/jsdoc3/jsdoc#readme"

    >jsdoc (v3.4.3)</a>
</h1>
<h4>An API documentation generator for JavaScript.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc">module jsdoc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser">
            function <span class="apidocSignatureSpan">jsdoc.</span>argparser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.config">
            function <span class="apidocSignatureSpan">jsdoc.</span>config
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.doop">
            function <span class="apidocSignatureSpan">jsdoc.</span>doop
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>argparser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>cast</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>config.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>dumper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>inline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>logger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.</span>publish</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.argparser">module jsdoc.argparser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.argparser">
            function <span class="apidocSignatureSpan">jsdoc.</span>argparser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.argparser.prototype">module jsdoc.argparser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.prototype._addOption">
            function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>_addOption
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.prototype._getOptionByLongName">
            function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>_getOptionByLongName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.prototype._getOptionByShortName">
            function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>_getOptionByShortName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.prototype.addIgnoredOption">
            function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>addIgnoredOption
            <span class="apidocSignatureSpan">(shortName, longName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.prototype.addOption">
            function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>addOption
            <span class="apidocSignatureSpan">(shortName, longName, hasValue, helpText, canHaveMultiple, coercer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.prototype.help">
            function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>help
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.argparser.prototype.parse">
            function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>parse
            <span class="apidocSignatureSpan">(args, defaults)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.cast">module jsdoc.cast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.cast.cast">
            function <span class="apidocSignatureSpan">jsdoc.</span>cast
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.config">module jsdoc.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.config.config">
            function <span class="apidocSignatureSpan">jsdoc.</span>config
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.config.prototype">module jsdoc.config.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.config.prototype.get">
            function <span class="apidocSignatureSpan">jsdoc.config.prototype.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.doop">module jsdoc.doop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.doop.doop">
            function <span class="apidocSignatureSpan">jsdoc.</span>doop
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.dumper">module jsdoc.dumper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.dumper.dump">
            function <span class="apidocSignatureSpan">jsdoc.dumper.</span>dump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.error">module jsdoc.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.error.handle">
            function <span class="apidocSignatureSpan">jsdoc.error.</span>handle
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.fs">module jsdoc.fs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.FileReadStream">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>FileReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.FileWriteStream">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>FileWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.ReadStream">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>ReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.Stats">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>Stats
            <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.WriteStream">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>WriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs._toUnixTimestamp">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>_toUnixTimestamp
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.access">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>access
            <span class="apidocSignatureSpan">(path, mode, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.accessSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>accessSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.appendFile">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>appendFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.appendFileSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>appendFileSync
            <span class="apidocSignatureSpan">(path, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.chmod">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>chmod
            <span class="apidocSignatureSpan">(path, mode, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.chmodSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>chmodSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.chown">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>chown
            <span class="apidocSignatureSpan">(path, uid, gid, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.chownSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>chownSync
            <span class="apidocSignatureSpan">(path, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.close">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>close
            <span class="apidocSignatureSpan">(fd, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.closeSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>closeSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.copyFileSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>copyFileSync
            <span class="apidocSignatureSpan">(inFile, outDir, fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.createReadStream">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>createReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.createWriteStream">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>createWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.exists">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>exists
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.existsSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>existsSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fchmod">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchmod
            <span class="apidocSignatureSpan">(fd, mode, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fchmodSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchmodSync
            <span class="apidocSignatureSpan">(fd, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fchown">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchown
            <span class="apidocSignatureSpan">(fd, uid, gid, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fchownSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchownSync
            <span class="apidocSignatureSpan">(fd, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fdatasync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fdatasync
            <span class="apidocSignatureSpan">(fd, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fdatasyncSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fdatasyncSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fstat">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fstat
            <span class="apidocSignatureSpan">(fd, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fstatSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fstatSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fsync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fsync
            <span class="apidocSignatureSpan">(fd, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.fsyncSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>fsyncSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.ftruncate">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>ftruncate
            <span class="apidocSignatureSpan">(fd, len, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.ftruncateSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>ftruncateSync
            <span class="apidocSignatureSpan">(fd, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.futimes">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>futimes
            <span class="apidocSignatureSpan">(fd, atime, mtime, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.futimesSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>futimesSync
            <span class="apidocSignatureSpan">(fd, atime, mtime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.link">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>link
            <span class="apidocSignatureSpan">(existingPath, newPath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.linkSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>linkSync
            <span class="apidocSignatureSpan">(existingPath, newPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.ls">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>ls
            <span class="apidocSignatureSpan">(dir, recurse, _allFiles, _path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.lstat">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>lstat
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.lstatSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>lstatSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.mkPath">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkPath
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.mkdir">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdir
            <span class="apidocSignatureSpan">(path, mode, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.mkdirSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdirSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.mkdtemp">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdtemp
            <span class="apidocSignatureSpan">(prefix, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.mkdtempSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdtempSync
            <span class="apidocSignatureSpan">(prefix, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.open">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>open
            <span class="apidocSignatureSpan">(path, flags, mode, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.openSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>openSync
            <span class="apidocSignatureSpan">(path, flags, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.read">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>read
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.readFile">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>readFile
            <span class="apidocSignatureSpan">(path, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.readFileSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>readFileSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.readSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>readSync
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.readdir">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>readdir
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.readdirSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>readdirSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.readlink">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>readlink
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.readlinkSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>readlinkSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.realpath">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>realpath
            <span class="apidocSignatureSpan">(p, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.realpathSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>realpathSync
            <span class="apidocSignatureSpan">(p, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.rename">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>rename
            <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.renameSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>renameSync
            <span class="apidocSignatureSpan">(oldPath, newPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.rmdir">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>rmdir
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.rmdirSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>rmdirSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.stat">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>stat
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.statSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>statSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.symlink">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>symlink
            <span class="apidocSignatureSpan">(target, path, type_, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.symlinkSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>symlinkSync
            <span class="apidocSignatureSpan">(target, path, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.toDir">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>toDir
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.truncate">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>truncate
            <span class="apidocSignatureSpan">(path, len, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.truncateSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>truncateSync
            <span class="apidocSignatureSpan">(path, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.unlink">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>unlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.unlinkSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>unlinkSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.unwatchFile">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>unwatchFile
            <span class="apidocSignatureSpan">(filename, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.utimes">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>utimes
            <span class="apidocSignatureSpan">(path, atime, mtime, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.utimesSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>utimesSync
            <span class="apidocSignatureSpan">(path, atime, mtime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.watch">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>watch
            <span class="apidocSignatureSpan">(filename, options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.watchFile">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>watchFile
            <span class="apidocSignatureSpan">(filename, options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.write">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>write
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.writeFile">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>writeFile
            <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.writeFileSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>writeFileSync
            <span class="apidocSignatureSpan">(path, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.fs.writeSync">
            function <span class="apidocSignatureSpan">jsdoc.fs.</span>writeSync
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsdoc.fs.</span>F_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsdoc.fs.</span>R_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsdoc.fs.</span>W_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">jsdoc.fs.</span>X_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.fs.</span>constants</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.inline">module jsdoc.inline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.inline.extractInlineTag">
            function <span class="apidocSignatureSpan">jsdoc.inline.</span>extractInlineTag
            <span class="apidocSignatureSpan">(string, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.inline.isInlineTag">
            function <span class="apidocSignatureSpan">jsdoc.inline.</span>isInlineTag
            <span class="apidocSignatureSpan">(string, tagName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.inline.replaceInlineTag">
            function <span class="apidocSignatureSpan">jsdoc.inline.</span>replaceInlineTag
            <span class="apidocSignatureSpan">(string, tag, replacer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.inline.replaceInlineTags">
            function <span class="apidocSignatureSpan">jsdoc.inline.</span>replaceInlineTags
            <span class="apidocSignatureSpan">(string, replacers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.logger">module jsdoc.logger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.debug">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.error">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.fatal">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>fatal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.getLevel">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>getLevel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.info">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>info
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.printDebug">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>printDebug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.printInfo">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>printInfo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.printVerbose">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>printVerbose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.setLevel">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>setLevel
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.verbose">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>verbose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.logger.warn">
            function <span class="apidocSignatureSpan">jsdoc.logger.</span>warn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.logger.</span>LEVELS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.name">module jsdoc.name</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.applyNamespace">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>applyNamespace
            <span class="apidocSignatureSpan">(longname, ns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.combine">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>combine
            <span class="apidocSignatureSpan">(parts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.hasAncestor">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>hasAncestor
            <span class="apidocSignatureSpan">(parent, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.longnamesToTree">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>longnamesToTree
            <span class="apidocSignatureSpan">(longnames, doclets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.resolve">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>resolve
            <span class="apidocSignatureSpan">(doclet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.shorten">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>shorten
            <span class="apidocSignatureSpan">(longname, forcedMemberof)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.splitName">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>splitName
            <span class="apidocSignatureSpan">(nameDesc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.stripNamespace">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>stripNamespace
            <span class="apidocSignatureSpan">(longname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.name.stripVariation">
            function <span class="apidocSignatureSpan">jsdoc.name.</span>stripVariation
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.name.</span>LONGNAMES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.name.</span>SCOPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.name.</span>puncToScope</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsdoc.name.</span>scopeToPunc</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsdoc.publish">module jsdoc.publish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsdoc.publish.publish">
            function <span class="apidocSignatureSpan">jsdoc.</span>publish
            <span class="apidocSignatureSpan">(data, opts)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc" id="apidoc.module.jsdoc">module jsdoc</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.argparser" id="apidoc.element.jsdoc.argparser">
        function <span class="apidocSignatureSpan">jsdoc.</span>argparser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">argparser = function () {
    this._options = [];
    this._shortNameIndex = {};
    this._longNameIndex = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.config" id="apidoc.element.jsdoc.config">
        function <span class="apidocSignatureSpan">jsdoc.</span>config
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(json) {
    json = JSON.parse( (json || &#x27;{}&#x27;) );
    this._config = mergeRecurse(defaults, json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.doop" id="apidoc.element.jsdoc.doop">
        function <span class="apidocSignatureSpan">jsdoc.</span>doop
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doopWrapper(o) {
    return doop(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    doclets.forEach(function(doclet) {
        if (doclet &#x26;&#x26; doclet.isEnum) {
doclet.properties = doclet.properties || [];

// members of an enum inherit the enum&#x27;s type
if (doclet.type &#x26;&#x26; !e.doclet.type) {
    // clone the type to prevent circular refs
    e.doclet.type = jsdoc.util.<span class="apidocCodeKeywordSpan">doop</span>(doclet.type);
}

delete e.doclet.undocumented;
e.doclet.defaultvalue = e.doclet.meta.code.value;

// add the doclet to the parent&#x27;s properties
doclet.properties.push(e.doclet);
...</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.argparser" id="apidoc.module.jsdoc.argparser">module jsdoc.argparser</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.argparser.argparser" id="apidoc.element.jsdoc.argparser.argparser">
        function <span class="apidocSignatureSpan">jsdoc.</span>argparser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">argparser = function () {
    this._options = [];
    this._shortNameIndex = {};
    this._longNameIndex = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.argparser.prototype" id="apidoc.module.jsdoc.argparser.prototype">module jsdoc.argparser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.argparser.prototype._addOption" id="apidoc.element.jsdoc.argparser.prototype._addOption">
        function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>_addOption
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addOption = function (option) {
    var currentIndex;

    var longName = option.longName;
    var shortName = option.shortName;

    this._options.push(option);
    currentIndex = this._options.length - 1;

    if (shortName) {
        this._shortNameIndex[shortName] = currentIndex;
    }
    if (longName) {
        this._longNameIndex[longName] = currentIndex;
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       longName: longName,
       hasValue: hasValue,
       helpText: helpText,
       canHaveMultiple: (canHaveMultiple || false),
       coercer: coercer
   };

   return this.<span class="apidocCodeKeywordSpan">_addOption</span>(option);
};

// TODO: refactor addOption to accept objects, then get rid of this method
/**
* Provide information about an option that should not cause an error if present, but that is always
* ignored (for example, an option that was used in previous versions but is no longer supported).
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.argparser.prototype._getOptionByLongName" id="apidoc.element.jsdoc.argparser.prototype._getOptionByLongName">
        function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>_getOptionByLongName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getOptionByLongName = function (name) {
    if (hasOwnProp.call(this._longNameIndex, name)) {
        return this._options[this._longNameIndex[name]];
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
value = null;

        // like -t
        if (arg.charAt(0) === &#x27;-&#x27;) {
// like --template
if (arg.charAt(1) === &#x27;-&#x27;) {
    name = longName = arg.slice(2);
    option = this.<span class="apidocCodeKeywordSpan">_getOptionByLongName</span>(longName);
}
else {
    name = shortName = arg.slice(1);
    option = this._getOptionByShortName(shortName);
}

if (option === null) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.argparser.prototype._getOptionByShortName" id="apidoc.element.jsdoc.argparser.prototype._getOptionByShortName">
        function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>_getOptionByShortName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getOptionByShortName = function (name) {
    if (hasOwnProp.call(this._shortNameIndex, name)) {
        return this._options[this._shortNameIndex[name]];
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// like --template
if (arg.charAt(1) === &#x27;-&#x27;) {
    name = longName = arg.slice(2);
    option = this._getOptionByLongName(longName);
}
else {
    name = shortName = arg.slice(1);
    option = this.<span class="apidocCodeKeywordSpan">_getOptionByShortName</span>(shortName);
}

if (option === null) {
    throw new Error( util.format(&#x27;Unknown command-line option &#x22;%s&#x22;.&#x27;, name) );
}

if (option.hasValue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.argparser.prototype.addIgnoredOption" id="apidoc.element.jsdoc.argparser.prototype.addIgnoredOption">
        function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>addIgnoredOption
        <span class="apidocSignatureSpan">(shortName, longName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addIgnoredOption = function (shortName, longName) {
    var option = {
        shortName: shortName,
        longName: longName,
        ignore: true
    };

    return this._addOption(option);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
argParser.addOption(&#x27;u&#x27;, &#x27;tutorials&#x27;,   true,  &#x27;Directory in which JSDoc should search for tutorials.&#
x27;);
argParser.addOption(&#x27;v&#x27;, &#x27;version&#x27;,     false, &#x27;Display the version number and quit.&#x27;);
argParser.addOption(&#x27;&#x27;,  &#x27;verbose&#x27;,     false, &#x27;Log detailed information to the console as JSDoc runs.&#
x27;);
argParser.addOption(&#x27;X&#x27;, &#x27;explain&#x27;,     false, &#x27;Dump all found doclet internals to console and quit.&#x27
;);
/* eslint-enable no-multi-spaces */

// Options that are no longer supported and should be ignored
argParser.<span class="apidocCodeKeywordSpan">addIgnoredOption</span>(&#x27;l&#x27;, &#x27;lenient&#x27;); // removed in JSDoc 3
.3.0

/**
 * Set the options for this app.
 * @throws {Error} Illegal arguments will throw errors.
 * @param {string|String[]} args The command line arguments for this app.
 */
exports.parse = function(args) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.argparser.prototype.addOption" id="apidoc.element.jsdoc.argparser.prototype.addOption">
        function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>addOption
        <span class="apidocSignatureSpan">(shortName, longName, hasValue, helpText, canHaveMultiple, coercer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOption = function (shortName, longName, hasValue, helpText, canHaveMultiple, coercer) {
    var option = {
        shortName: shortName,
        longName: longName,
        hasValue: hasValue,
        helpText: helpText,
        canHaveMultiple: (canHaveMultiple || false),
        coercer: coercer
    };

    return this._addOption(option);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string}    longName The equivalent long name of the option, entered like: --test.
 * @param {boolean}   hasValue Does this option require a value? Like: -t templatename
 * @param {string}    helpText A brief description of the option.
 * @param {boolean}   [canHaveMultiple=false] Set to `true` if the option can be provided more than once.
 * @param {function}  [coercer] A function to coerce the given value to a specific type.
 * @return {this}
 * @example
 * myParser.<span class="apidocCodeKeywordSpan">addOption</span>(&#x27;t&#x27;, &#x27;template&#x27;, true, &#x27;The path to the
 template.&#x27;);
 * myParser.addOption(&#x27;h&#x27;, &#x27;help&#x27;, false, &#x27;Show the help message.&#x27;);
 */
ArgParser.prototype.addOption = function(shortName, longName, hasValue, helpText, canHaveMultiple, coercer) {
var option = {
    shortName: shortName,
    longName: longName,
    hasValue: hasValue,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.argparser.prototype.help" id="apidoc.element.jsdoc.argparser.prototype.help">
        function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>help
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">help = function () {
    var options = {
        names: [],
        descriptions: []
    };

    this._options.forEach(function(option) {
        var name = &#x27;&#x27;;

        // don&#x27;t show ignored options
        if (option.ignore) {
            return;
        }

        if (option.shortName) {
            name += &#x27;-&#x27; + option.shortName + (option.longName ? &#x27;, &#x27; : &#x27;&#x27;);
        }

        if (option.longName) {
            name += &#x27;--&#x27; + option.longName;
        }

        if (option.hasValue) {
            name += &#x27; &#x3c;value&#x3e;&#x27;;
        }

        options.names.push(name);
        options.descriptions.push(option.helpText);
    });

    return &#x27;Options:\n&#x27; + formatHelpInfo(options).join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(errorCode);
});
};

// TODO: docs
cli.printHelp = function() {
cli.printVersion();
console.log( &#x27;\n&#x27; + require(&#x27;jsdoc/opts/args&#x27;).<span class="apidocCodeKeywordSpan">help</span>() + &#x27;\n&#
x27; );
console.log(&#x27;Visit http://usejsdoc.org for more information.&#x27;);
return Promise.resolve(0);
};

// TODO: docs
cli.runTests = function() {
var path = require(&#x27;jsdoc/path&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.argparser.prototype.parse" id="apidoc.element.jsdoc.argparser.prototype.parse">
        function <span class="apidocSignatureSpan">jsdoc.argparser.prototype.</span>parse
        <span class="apidocSignatureSpan">(args, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (args, defaults) {
    var result = defaults &#x26;&#x26; _.defaults({}, defaults) || {};

    result._ = [];
    for (var i = 0, leni = args.length; i &#x3c; leni; i++) {
        var arg = &#x27;&#x27; + args[i],
            next = (i &#x3c; leni - 1) ? &#x27;&#x27; + args[i + 1] : null,
            option,
            shortName = null,
            longName,
            name,
            value = null;

        // like -t
        if (arg.charAt(0) === &#x27;-&#x27;) {
            // like --template
            if (arg.charAt(1) === &#x27;-&#x27;) {
                name = longName = arg.slice(2);
                option = this._getOptionByLongName(longName);
            }
            else {
                name = shortName = arg.slice(1);
                option = this._getOptionByShortName(shortName);
            }

            if (option === null) {
                throw new Error( util.format(&#x27;Unknown command-line option &#x22;%s&#x22;.&#x27;, name) );
            }

            if (option.hasValue) {
                value = next;
                i++;

                if (value === null || value.charAt(0) === &#x27;-&#x27;) {
                    throw new Error( util.format(&#x27;The command-line option &#x22;%s&#x22; requires a value.&#x27;, name) );
                }
            }
            else {
                value = true;
            }

            // skip ignored options now that we&#x27;ve consumed the option text
            if (option.ignore) {
                continue;
            }

            if (option.longName &#x26;&#x26; shortName) {
                name = option.longName;
            }

            if (typeof option.coercer === &#x27;function&#x27;) {
                value = option.coercer(value);
            }

            // Allow for multiple options of the same type to be present
            if (option.canHaveMultiple &#x26;&#x26; hasOwnProp.call(result, name)) {
                var val = result[name];

                if (val instanceof Array) {
                    val.push(value);
                } else {
                    result[name] = [val, value];
                }
            }
            else {
                result[name] = value;
            }
        }
        else {
            result._.push(arg);
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// TODO: docs
cli.setVersionInfo = function() {
var fs = require(&#x27;fs&#x27;);
var path = require(&#x27;path&#x27;);

// allow this to throw--something is really wrong if we can&#x27;t read our own package file
var info = JSON.<span class="apidocCodeKeywordSpan">parse</span>( fs.readFileSync(path.join(env.dirname, &#x27;package.json&#x27
;), &#x27;utf8&#x27;) );

env.version = {
    number: info.version,
    revision: new Date( parseInt(info.revision, 10) ).toUTCString()
};

return cli;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.cast" id="apidoc.module.jsdoc.cast">module jsdoc.cast</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.cast.cast" id="apidoc.element.jsdoc.cast.cast">
        function <span class="apidocSignatureSpan">jsdoc.</span>cast
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cast(item) {
    var result;

    if ( Array.isArray(item) ) {
        result = [];
        for (var i = 0, l = item.length; i &#x3c; l; i++) {
            result[i] = cast(item[i]);
        }
    }
    else if (typeof item === &#x27;object&#x27; &#x26;&#x26; item !== null) {
        result = {};
        Object.keys(item).forEach(function(prop) {
            result[prop] = cast(item[prop]);
        });
    }
    else if (typeof item === &#x27;string&#x27;) {
        result = castString(item);
    }
    else {
        result = item;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (RegExp.$1 &#x26;&#x26; RegExp.$3) {
            tagInfo.optional = true;
        }

        // like &#x27;foo=bar&#x27; or &#x27;foo = bar&#x27;
        if ( /^(.+?)\s*=\s*(.+)$/.test(tagInfo.name) ) {
            tagInfo.name = RegExp.$1;
            tagInfo.defaultvalue = jsdoc.util.cast.<span class="apidocCodeKeywordSpan">cast</span>(RegExp.$2);
        }
    }

    return tagInfo;
}

/** @private */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.config" id="apidoc.module.jsdoc.config">module jsdoc.config</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.config.config" id="apidoc.element.jsdoc.config.config">
        function <span class="apidocSignatureSpan">jsdoc.</span>config
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(json) {
    json = JSON.parse( (json || &#x27;{}&#x27;) );
    this._config = mergeRecurse(defaults, json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.config.prototype" id="apidoc.module.jsdoc.config.prototype">module jsdoc.config.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.config.prototype.get" id="apidoc.element.jsdoc.config.prototype.get">
        function <span class="apidocSignatureSpan">jsdoc.config.prototype.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function () {
    return this._config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if ( !isFile &#x26;&#x26; !env.opts.configure ) {
    confPath = path.join(env.dirname, &#x27;conf.json.EXAMPLE&#x27;);
}

try {
    env.conf = new Config( stripJsonComments(fs.readFileSync(confPath, &#x27;utf8&#x27;)) )
        .<span class="apidocCodeKeywordSpan">get</span>();
}
catch (e) {
    cli.exit(1, &#x27;Cannot parse the config file &#x27; + confPath + &#x27;: &#x27; + e + &#x27;\n&#x27; +
        FATAL_ERROR_MESSAGE);
}

// look for options on the command line, in the config file, and in the defaults, in that order
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.doop" id="apidoc.module.jsdoc.doop">module jsdoc.doop</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.doop.doop" id="apidoc.element.jsdoc.doop.doop">
        function <span class="apidocSignatureSpan">jsdoc.</span>doop
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doopWrapper(o) {
    return doop(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    doclets.forEach(function(doclet) {
        if (doclet &#x26;&#x26; doclet.isEnum) {
doclet.properties = doclet.properties || [];

// members of an enum inherit the enum&#x27;s type
if (doclet.type &#x26;&#x26; !e.doclet.type) {
    // clone the type to prevent circular refs
    e.doclet.type = jsdoc.util.<span class="apidocCodeKeywordSpan">doop</span>(doclet.type);
}

delete e.doclet.undocumented;
e.doclet.defaultvalue = e.doclet.meta.code.value;

// add the doclet to the parent&#x27;s properties
doclet.properties.push(e.doclet);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.dumper" id="apidoc.module.jsdoc.dumper">module jsdoc.dumper</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.dumper.dump" id="apidoc.element.jsdoc.dumper.dump">
        function <span class="apidocSignatureSpan">jsdoc.dumper.</span>dump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dump = function () {
    var args = Array.prototype.slice.call(arguments, 0);
    var result = [];
    var walker;

    for (var i = 0, l = args.length; i &#x3c; l; i++) {
        walker = new ObjectWalker();
        result.push( JSON.stringify(walker.walk(args[i]), null, 4) );
    }

    return result.join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else {
    cli.resolveTutorials();
    return cli.generateDocs();
}
};

cli.dumpParseResults = function() {
console.log(require(&#x27;jsdoc/util/dumper&#x27;).<span class="apidocCodeKeywordSpan">dump</span>(props.docs));

return cli;
};

cli.resolveTutorials = function() {
var resolver = require(&#x27;jsdoc/tutorial/resolver&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.error" id="apidoc.module.jsdoc.error">module jsdoc.error</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.error.handle" id="apidoc.element.jsdoc.error.handle">
        function <span class="apidocSignatureSpan">jsdoc.error.</span>handle
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handle = function (e) {
    var logger = require(&#x27;jsdoc/util/logger&#x27;);
    var msg = e ? ( e.message || JSON.stringify(e) ) : &#x27;&#x27;;

    // include the error type if it&#x27;s an Error object
    if (e instanceof Error) {
        msg = e.name + &#x27;: &#x27; + msg;
    }

    logger.error(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.fs" id="apidoc.module.jsdoc.fs">module jsdoc.fs</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.fs.FileReadStream" id="apidoc.element.jsdoc.fs.FileReadStream">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>FileReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === &#x27;string&#x27;)
    options = { encoding: options };
  else if (options === null || typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; argument must be a string or an object&#x27;);

  // a little bit bigger buffer and water marks by default
  options = Object.create(options);
  if (options.highWaterMark === undefined)
    options.highWaterMark = 64 * 1024;

  Readable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? &#x27;r&#x27; : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  this.bytesRead = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== &#x27;number&#x27;) {
      throw new TypeError(&#x27;&#x22;start&#x22; option must be a Number&#x27;);
    }
    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== &#x27;number&#x27;) {
      throw new TypeError(&#x27;&#x22;end&#x22; option must be a Number&#x27;);
    }

    if (this.start &#x3e; this.end) {
      throw new Error(&#x27;&#x22;start&#x22; option must be &#x3c;= &#x22;end&#x22; option&#x27;);
    }

    this.pos = this.start;
  }

  if (typeof this.fd !== &#x27;number&#x27;)
    this.open();

  this.on(&#x27;end&#x27;, function() {
    if (this.autoClose) {
      this.destroy();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.FileWriteStream" id="apidoc.element.jsdoc.fs.FileWriteStream">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>FileWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (!(this instanceof WriteStream))
    return new WriteStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === &#x27;string&#x27;)
    options = { encoding: options };
  else if (options === null || typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; argument must be a string or an object&#x27;);

  options = Object.create(options);

  Writable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? &#x27;w&#x27; : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
  this.pos = undefined;
  this.bytesWritten = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== &#x27;number&#x27;) {
      throw new TypeError(&#x27;&#x22;start&#x22; option must be a Number&#x27;);
    }
    if (this.start &#x3c; 0) {
      throw new Error(&#x27;&#x22;start&#x22; must be &#x3e;= zero&#x27;);
    }

    this.pos = this.start;
  }

  if (options.encoding)
    this.setDefaultEncoding(options.encoding);

  if (typeof this.fd !== &#x27;number&#x27;)
    this.open();

  // dispose on finish.
  this.once(&#x27;finish&#x27;, function() {
    if (this.autoClose) {
      this.close();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.ReadStream" id="apidoc.element.jsdoc.fs.ReadStream">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>ReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === &#x27;string&#x27;)
    options = { encoding: options };
  else if (options === null || typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; argument must be a string or an object&#x27;);

  // a little bit bigger buffer and water marks by default
  options = Object.create(options);
  if (options.highWaterMark === undefined)
    options.highWaterMark = 64 * 1024;

  Readable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? &#x27;r&#x27; : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  this.bytesRead = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== &#x27;number&#x27;) {
      throw new TypeError(&#x27;&#x22;start&#x22; option must be a Number&#x27;);
    }
    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== &#x27;number&#x27;) {
      throw new TypeError(&#x27;&#x22;end&#x22; option must be a Number&#x27;);
    }

    if (this.start &#x3e; this.end) {
      throw new Error(&#x27;&#x22;start&#x22; option must be &#x3c;= &#x22;end&#x22; option&#x27;);
    }

    this.pos = this.start;
  }

  if (typeof this.fd !== &#x27;number&#x27;)
    this.open();

  this.on(&#x27;end&#x27;, function() {
    if (this.autoClose) {
      this.destroy();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.Stats" id="apidoc.element.jsdoc.fs.Stats">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>Stats
        <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = new Date(atim_msec);
  this.mtime = new Date(mtim_msec);
  this.ctime = new Date(ctim_msec);
  this.birthtime = new Date(birthtim_msec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.WriteStream" id="apidoc.element.jsdoc.fs.WriteStream">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>WriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (!(this instanceof WriteStream))
    return new WriteStream(path, options);

  if (options === undefined)
    options = {};
  else if (typeof options === &#x27;string&#x27;)
    options = { encoding: options };
  else if (options === null || typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; argument must be a string or an object&#x27;);

  options = Object.create(options);

  Writable.call(this, options);

  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? &#x27;w&#x27; : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;

  this.start = options.start;
  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
  this.pos = undefined;
  this.bytesWritten = 0;

  if (this.start !== undefined) {
    if (typeof this.start !== &#x27;number&#x27;) {
      throw new TypeError(&#x27;&#x22;start&#x22; option must be a Number&#x27;);
    }
    if (this.start &#x3c; 0) {
      throw new Error(&#x27;&#x22;start&#x22; must be &#x3e;= zero&#x27;);
    }

    this.pos = this.start;
  }

  if (options.encoding)
    this.setDefaultEncoding(options.encoding);

  if (typeof this.fd !== &#x27;number&#x27;)
    this.open();

  // dispose on finish.
  this.once(&#x27;finish&#x27;, function() {
    if (this.autoClose) {
      this.close();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs._toUnixTimestamp" id="apidoc.element.jsdoc.fs._toUnixTimestamp">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>_toUnixTimestamp
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toUnixTimestamp(time) {
  if (typeof time === &#x27;string&#x27; &#x26;&#x26; +time == time) {
    return +time;
  }
  if (typeof time === &#x27;number&#x27;) {
    if (!Number.isFinite(time) || time &#x3c; 0) {
      return Date.now() / 1000;
    }
    return time;
  }
  if (util.isDate(time)) {
    // convert to 123.456 UNIX timestamp
    return time.getTime() / 1000;
  }
  throw new Error(&#x27;Cannot parse time: &#x27; + time);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.access" id="apidoc.element.jsdoc.fs.access">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>access
        <span class="apidocSignatureSpan">(path, mode, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">access = function (path, mode, callback) {
  if (typeof mode === &#x27;function&#x27;) {
    callback = mode;
    mode = fs.F_OK;
  } else if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;&#x22;callback&#x22; argument must be a function&#x27;);
  }

  if (!nullCheck(path, callback))
    return;

  mode = mode | 0;
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.access(pathModule._makeLong(path), mode, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.accessSync" id="apidoc.element.jsdoc.fs.accessSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>accessSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accessSync = function (path, mode) {
  nullCheck(path);

  if (mode === undefined)
    mode = fs.F_OK;
  else
    mode = mode | 0;

  binding.access(pathModule._makeLong(path), mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.appendFile" id="apidoc.element.jsdoc.fs.appendFile">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>appendFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFile = function (path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  if (!options.flag)
    options = util._extend({ flag: &#x27;a&#x27; }, options);

  // force append behavior when using a supplied file descriptor
  if (isFd(path))
    options.flag = &#x27;a&#x27;;

  fs.writeFile(path, data, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.appendFileSync" id="apidoc.element.jsdoc.fs.appendFileSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>appendFileSync
        <span class="apidocSignatureSpan">(path, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFileSync = function (path, data, options) {
  if (!options) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  if (!options.flag)
    options = util._extend({ flag: &#x27;a&#x27; }, options);

  // force append behavior when using a supplied file descriptor
  if (isFd(path))
    options.flag = &#x27;a&#x27;;

  fs.writeFileSync(path, data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.chmod" id="apidoc.element.jsdoc.fs.chmod">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>chmod
        <span class="apidocSignatureSpan">(path, mode, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function (path, mode, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.chmod(pathModule._makeLong(path),
                modeNum(mode),
                req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.chmodSync" id="apidoc.element.jsdoc.fs.chmodSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>chmodSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmodSync = function (path, mode) {
  nullCheck(path);
  return binding.chmod(pathModule._makeLong(path), modeNum(mode));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.chown" id="apidoc.element.jsdoc.fs.chown">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>chown
        <span class="apidocSignatureSpan">(path, uid, gid, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chown = function (path, uid, gid, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.chown(pathModule._makeLong(path), uid, gid, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.chownSync" id="apidoc.element.jsdoc.fs.chownSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>chownSync
        <span class="apidocSignatureSpan">(path, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chownSync = function (path, uid, gid) {
  nullCheck(path);
  return binding.chown(pathModule._makeLong(path), uid, gid);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.close" id="apidoc.element.jsdoc.fs.close">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>close
        <span class="apidocSignatureSpan">(fd, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.close(fd, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.closeSync" id="apidoc.element.jsdoc.fs.closeSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>closeSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeSync = function (fd) {
  return binding.close(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    while (bytesRead &#x3e; 0) {
        bytesRead = fs.readSync(read, buffer, 0, BUF_LENGTH, pos);
        fs.writeSync(write, buffer, 0, bytesRead);
        pos += bytesRead;
    }

    fs.<span class="apidocCodeKeywordSpan">closeSync</span>(read);
    return fs.closeSync(write);
};

Object.keys(fs).forEach(function(member) {
    exports[member] = fs[member];
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.copyFileSync" id="apidoc.element.jsdoc.fs.copyFileSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>copyFileSync
        <span class="apidocSignatureSpan">(inFile, outDir, fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyFileSync = function (inFile, outDir, fileName) {
    var BUF_LENGTH = 64 * 1024;

    var read;
    var write;

    var buffer = new Buffer(BUF_LENGTH);
    var bytesRead = 1;
    var outFile = path.join( outDir, fileName || path.basename(inFile) );
    var pos = 0;

    mkdirp.sync(outDir);
    read = fs.openSync(inFile, &#x27;r&#x27;);
    write = fs.openSync(outFile, &#x27;w&#x27;);

    while (bytesRead &#x3e; 0) {
        bytesRead = fs.readSync(read, buffer, 0, BUF_LENGTH, pos);
        fs.writeSync(write, buffer, 0, bytesRead);
        pos += bytesRead;
    }

    fs.closeSync(read);
    return fs.closeSync(write);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// copy the template&#x27;s static files to outdir
var fromDir = path.join(templatePath, &#x27;static&#x27;);
var staticFiles = fs.ls(fromDir, 3);

staticFiles.forEach(function(fileName) {
    var toDir = fs.toDir( fileName.replace(fromDir, outdir) );
    fs.mkPath(toDir);
    fs.<span class="apidocCodeKeywordSpan">copyFileSync</span>(fileName, toDir);
});

// copy user-specified static files to outdir
var staticFilePaths;
var staticFileFilter;
var staticFileScanner;
if (conf.default.staticFiles) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.createReadStream" id="apidoc.element.jsdoc.fs.createReadStream">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>createReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReadStream = function (path, options) {
  return new ReadStream(path, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.createWriteStream" id="apidoc.element.jsdoc.fs.createWriteStream">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>createWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriteStream = function (path, options) {
  return new WriteStream(path, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.exists" id="apidoc.element.jsdoc.fs.exists">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>exists
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path, callback) {
  if (!nullCheck(path, cb)) return;
  var req = new FSReqWrap();
  req.oncomplete = cb;
  binding.stat(pathModule._makeLong(path), req);
  function cb(err, stats) {
    if (callback) callback(err ? false : true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.existsSync" id="apidoc.element.jsdoc.fs.existsSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>existsSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsSync = function (path) {
  try {
    nullCheck(path);
    binding.stat(pathModule._makeLong(path), statValues);
    return true;
  } catch (e) {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fchmod" id="apidoc.element.jsdoc.fs.fchmod">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchmod
        <span class="apidocSignatureSpan">(fd, mode, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmod = function (fd, mode, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fchmod(fd, modeNum(mode), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fchmodSync" id="apidoc.element.jsdoc.fs.fchmodSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchmodSync
        <span class="apidocSignatureSpan">(fd, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmodSync = function (fd, mode) {
  return binding.fchmod(fd, modeNum(mode));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fchown" id="apidoc.element.jsdoc.fs.fchown">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchown
        <span class="apidocSignatureSpan">(fd, uid, gid, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchown = function (fd, uid, gid, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fchown(fd, uid, gid, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fchownSync" id="apidoc.element.jsdoc.fs.fchownSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fchownSync
        <span class="apidocSignatureSpan">(fd, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchownSync = function (fd, uid, gid) {
  return binding.fchown(fd, uid, gid);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fdatasync" id="apidoc.element.jsdoc.fs.fdatasync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fdatasync
        <span class="apidocSignatureSpan">(fd, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fdatasync = function (fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fdatasync(fd, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fdatasyncSync" id="apidoc.element.jsdoc.fs.fdatasyncSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fdatasyncSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fdatasyncSync = function (fd) {
  return binding.fdatasync(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fstat" id="apidoc.element.jsdoc.fs.fstat">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fstat
        <span class="apidocSignatureSpan">(fd, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstat = function (fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fstat(fd, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fstatSync" id="apidoc.element.jsdoc.fs.fstatSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fstatSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstatSync = function (fd) {
  binding.fstat(fd, statValues);
  return statsFromValues();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fsync" id="apidoc.element.jsdoc.fs.fsync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fsync
        <span class="apidocSignatureSpan">(fd, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsync = function (fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fsync(fd, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.fsyncSync" id="apidoc.element.jsdoc.fs.fsyncSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>fsyncSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsyncSync = function (fd) {
  return binding.fsync(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.ftruncate" id="apidoc.element.jsdoc.fs.ftruncate">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>ftruncate
        <span class="apidocSignatureSpan">(fd, len, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ftruncate = function (fd, len, callback) {
  if (typeof len === &#x27;function&#x27;) {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  }
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.ftruncate(fd, len, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.ftruncateSync" id="apidoc.element.jsdoc.fs.ftruncateSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>ftruncateSync
        <span class="apidocSignatureSpan">(fd, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ftruncateSync = function (fd, len) {
  if (len === undefined) {
    len = 0;
  }
  return binding.ftruncate(fd, len);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.futimes" id="apidoc.element.jsdoc.fs.futimes">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>futimes
        <span class="apidocSignatureSpan">(fd, atime, mtime, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimes = function (fd, atime, mtime, callback) {
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.futimes(fd, atime, mtime, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.futimesSync" id="apidoc.element.jsdoc.fs.futimesSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>futimesSync
        <span class="apidocSignatureSpan">(fd, atime, mtime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimesSync = function (fd, atime, mtime) {
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.futimes(fd, atime, mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.link" id="apidoc.element.jsdoc.fs.link">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>link
        <span class="apidocSignatureSpan">(existingPath, newPath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (existingPath, newPath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(existingPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;

  var req = new FSReqWrap();
  req.oncomplete = callback;

  binding.link(pathModule._makeLong(existingPath),
               pathModule._makeLong(newPath),
               req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.linkSync" id="apidoc.element.jsdoc.fs.linkSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>linkSync
        <span class="apidocSignatureSpan">(existingPath, newPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linkSync = function (existingPath, newPath) {
  nullCheck(existingPath);
  nullCheck(newPath);
  return binding.link(pathModule._makeLong(existingPath),
                      pathModule._makeLong(newPath));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.ls" id="apidoc.element.jsdoc.fs.ls">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>ls
        <span class="apidocSignatureSpan">(dir, recurse, _allFiles, _path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ls = function (dir, recurse, _allFiles, _path) {
    var file;
    var files;
    var isFile;

    // first pass
    if (_path === undefined) {
        _allFiles = [];
        _path = [dir];
    }

    if (!_path.length) {
        return _allFiles;
    }

    if (recurse === undefined) {
        recurse = 1;
    }

    try {
        isFile = fs.statSync(dir).isFile();
    }
    catch (e) {
        isFile = false;
    }
    if (isFile) {
        files = [dir];
    }
    else {
        files = fs.readdirSync(dir);
    }

    for (var i = 0, l = files.length; i &#x3c; l; i++) {
        file = String(files[i]);

        // skip dot files
        if (file.match(/^\.[^\.\/\\]/)) {
            continue;
        }

        if ( fs.statSync(path.join(_path.join(&#x27;/&#x27;), file)).isDirectory() ) {
            // it&#x27;s a directory
            _path.push(file);

            if (_path.length - 1 &#x3c; recurse) {
                ls(_path.join(&#x27;/&#x27;), recurse, _allFiles, _path);
            }
            _path.pop();
        }
        else {
            // it&#x27;s a file
            _allFiles.push( path.normalize(path.join(_path.join(&#x27;/&#x27;), file)) );
        }
    }

    return _allFiles;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (packageInfo &#x26;&#x26; packageInfo.name) {
    outdir = path.join( outdir, packageInfo.name, (packageInfo.version || &#x27;&#x27;) );
}
fs.mkPath(outdir);

// copy the template&#x27;s static files to outdir
var fromDir = path.join(templatePath, &#x27;static&#x27;);
var staticFiles = fs.<span class="apidocCodeKeywordSpan">ls</span>(fromDir, 3);

staticFiles.forEach(function(fileName) {
    var toDir = fs.toDir( fileName.replace(fromDir, outdir) );
    fs.mkPath(toDir);
    fs.copyFileSync(fileName, toDir);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.lstat" id="apidoc.element.jsdoc.fs.lstat">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>lstat
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstat = function (path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.lstat(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.lstatSync" id="apidoc.element.jsdoc.fs.lstatSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>lstatSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstatSync = function (path) {
  nullCheck(path);
  binding.lstat(pathModule._makeLong(path), statValues);
  return statsFromValues();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.mkPath" id="apidoc.element.jsdoc.fs.mkPath">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkPath
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkPath = function (_path) {
    if ( Array.isArray(_path) ) {
        _path = _path.join(&#x27;&#x27;);
    }

    mkdirp.sync(_path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// update outdir if necessary, then create outdir
var packageInfo = ( find({kind: &#x27;package&#x27;}) || [] ) [0];
if (packageInfo &#x26;&#x26; packageInfo.name) {
    outdir = path.join( outdir, packageInfo.name, (packageInfo.version || &#x27;&#x27;) );
}
fs.<span class="apidocCodeKeywordSpan">mkPath</span>(outdir);

// copy the template&#x27;s static files to outdir
var fromDir = path.join(templatePath, &#x27;static&#x27;);
var staticFiles = fs.ls(fromDir, 3);

staticFiles.forEach(function(fileName) {
    var toDir = fs.toDir( fileName.replace(fromDir, outdir) );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.mkdir" id="apidoc.element.jsdoc.fs.mkdir">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdir
        <span class="apidocSignatureSpan">(path, mode, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function (path, mode, callback) {
  if (typeof mode === &#x27;function&#x27;) callback = mode;
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.mkdir(pathModule._makeLong(path),
                modeNum(mode, 0o777),
                req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.mkdirSync" id="apidoc.element.jsdoc.fs.mkdirSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdirSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirSync = function (path, mode) {
  nullCheck(path);
  return binding.mkdir(pathModule._makeLong(path),
                       modeNum(mode, 0o777));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.mkdtemp" id="apidoc.element.jsdoc.fs.mkdtemp">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdtemp
        <span class="apidocSignatureSpan">(prefix, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdtemp = function (prefix, options, callback) {
  if (!prefix || typeof prefix !== &#x27;string&#x27;)
    throw new TypeError(&#x27;filename prefix is required&#x27;);

  options = options || {};
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  }
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);

  callback = makeCallback(callback);
  if (!nullCheck(prefix, callback)) {
    return;
  }

  var req = new FSReqWrap();
  req.oncomplete = callback;

  binding.mkdtemp(prefix + &#x27;XXXXXX&#x27;, options.encoding, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.mkdtempSync" id="apidoc.element.jsdoc.fs.mkdtempSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>mkdtempSync
        <span class="apidocSignatureSpan">(prefix, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdtempSync = function (prefix, options) {
  if (!prefix || typeof prefix !== &#x27;string&#x27;)
    throw new TypeError(&#x27;filename prefix is required&#x27;);

  options = options || {};
  if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(prefix);

  return binding.mkdtemp(prefix + &#x27;XXXXXX&#x27;, options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.open" id="apidoc.element.jsdoc.fs.open">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>open
        <span class="apidocSignatureSpan">(path, flags, mode, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function (path, flags, mode, callback_) {
  var callback = makeCallback(arguments[arguments.length - 1]);
  mode = modeNum(mode, 0o666);

  if (!nullCheck(path, callback)) return;

  var req = new FSReqWrap();
  req.oncomplete = callback;

  binding.open(pathModule._makeLong(path),
               stringToFlags(flags),
               mode,
               req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.openSync" id="apidoc.element.jsdoc.fs.openSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>openSync
        <span class="apidocSignatureSpan">(path, flags, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openSync = function (path, flags, mode) {
  mode = modeNum(mode, 0o666);
  nullCheck(path);
  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var buffer = new Buffer(BUF_LENGTH);
var bytesRead = 1;
var outFile = path.join( outDir, fileName || path.basename(inFile) );
var pos = 0;

mkdirp.sync(outDir);
read = fs.<span class="apidocCodeKeywordSpan">openSync</span>(inFile, &#x27;r&#x27;);
write = fs.openSync(outFile, &#x27;w&#x27;);

while (bytesRead &#x3e; 0) {
    bytesRead = fs.readSync(read, buffer, 0, BUF_LENGTH, pos);
    fs.writeSync(write, buffer, 0, bytesRead);
    pos += bytesRead;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.read" id="apidoc.element.jsdoc.fs.read">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>read
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (fd, buffer, offset, length, position, callback) {
  if (!(buffer instanceof Buffer)) {
    // legacy string interface (fd, length, position, encoding, callback)
    readWarned = printDeprecation(&#x27;fs.read\&#x27;s legacy String interface &#x27; +
                                  &#x27;is deprecated. Use the Buffer API as &#x27; +
                                  &#x27;mentioned in the documentation instead.&#x27;,
                                  readWarned);
    const cb = arguments[4];
    const encoding = arguments[3];

    assertEncoding(encoding);

    position = arguments[2];
    length = arguments[1];
    buffer = Buffer.allocUnsafe(length);
    offset = 0;

    callback = function(err, bytesRead) {
      if (!cb) return;
      if (err) return cb(err);

      if (bytesRead &#x3e; 0) {
        tryToStringWithEnd(buffer, encoding, bytesRead, cb);
      } else {
        (cb)(err, &#x27;&#x27;, bytesRead);
      }
    };
  }

  if (length === 0) {
    return process.nextTick(function() {
      callback &#x26;&#x26; callback(null, 0, buffer);
    });
  }

  function wrapper(err, bytesRead) {
    // Retain a reference to buffer so that it can&#x27;t be GC&#x27;ed too soon.
    callback &#x26;&#x26; callback(err, bytesRead || 0, buffer);
  }

  var req = new FSReqWrap();
  req.oncomplete = wrapper;

  binding.read(fd, buffer, offset, length, position, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.readFile" id="apidoc.element.jsdoc.fs.readFile">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>readFile
        <span class="apidocSignatureSpan">(path, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (path, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: null, flag: &#x27;r&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, flag: &#x27;r&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  var encoding = options.encoding;
  assertEncoding(encoding);

  var flag = options.flag || &#x27;r&#x27;;

  if (!nullCheck(path, callback))
    return;

  var context = new ReadFileContext(callback, encoding);
  context.isUserFd = isFd(path); // file descriptor ownership
  var req = new FSReqWrap();
  req.context = context;
  req.oncomplete = readFileAfterOpen;

  if (context.isUserFd) {
    process.nextTick(function() {
      req.oncomplete(null, path);
    });
    return;
  }

  binding.open(pathModule._makeLong(path),
               stringToFlags(flag),
               0o666,
               req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.readFileSync" id="apidoc.element.jsdoc.fs.readFileSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>readFileSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileSync = function (path, options) {
  if (!options) {
    options = { encoding: null, flag: &#x27;r&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, flag: &#x27;r&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  var encoding = options.encoding;
  assertEncoding(encoding);

  var flag = options.flag || &#x27;r&#x27;;
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, 0o666);

  var st = tryStatSync(fd, isUserFd);
  var size = st.isFile() ? st.size : 0;
  var pos = 0;
  var buffer; // single buffer with file data
  var buffers; // list for when size is unknown

  if (size === 0) {
    buffers = [];
  } else {
    buffer = tryCreateBuffer(size, fd, isUserFd);
  }

  var bytesRead;

  if (size !== 0) {
    do {
      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);
      pos += bytesRead;
    } while (bytesRead !== 0 &#x26;&#x26; pos &#x3c; size);
  } else {
    do {
      // the kernel lies about many files.
      // Go ahead and try to read some bytes.
      buffer = Buffer.allocUnsafe(8192);
      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);
      if (bytesRead !== 0) {
        buffers.push(buffer.slice(0, bytesRead));
      }
      pos += bytesRead;
    } while (bytesRead !== 0);
  }

  if (!isUserFd)
    fs.closeSync(fd);

  if (size === 0) {
    // data was collected into the buffers list.
    buffer = Buffer.concat(buffers, pos);
  } else if (pos &#x3c; size) {
    buffer = buffer.slice(0, pos);
  }

  if (encoding) buffer = buffer.toString(encoding);
  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// TODO: docs
cli.setVersionInfo = function() {
var fs = require(&#x27;fs&#x27;);
var path = require(&#x27;path&#x27;);

// allow this to throw--something is really wrong if we can&#x27;t read our own package file
var info = JSON.parse( fs.<span class="apidocCodeKeywordSpan">readFileSync</span>(path.join(env.dirname, &#x27;package.json&#x27
;), &#x27;utf8&#x27;) );

env.version = {
    number: info.version,
    revision: new Date( parseInt(info.revision, 10) ).toUTCString()
};

return cli;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.readSync" id="apidoc.element.jsdoc.fs.readSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>readSync
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readSync = function (fd, buffer, offset, length, position) {
  var legacy = false;
  var encoding;

  if (!(buffer instanceof Buffer)) {
    // legacy string interface (fd, length, position, encoding, callback)
    readSyncWarned = printDeprecation(&#x27;fs.readSync\&#x27;s legacy String interface&#x27; +
                                      &#x27;is deprecated. Use the Buffer API as &#x27; +
                                      &#x27;mentioned in the documentation instead.&#x27;,
                                      readSyncWarned);
    legacy = true;
    encoding = arguments[3];

    assertEncoding(encoding);

    position = arguments[2];
    length = arguments[1];
    buffer = Buffer.allocUnsafe(length);

    offset = 0;
  }

  if (length === 0) {
    if (legacy) {
      return [&#x27;&#x27;, 0];
    } else {
      return 0;
    }
  }

  var r = binding.read(fd, buffer, offset, length, position);
  if (!legacy) {
    return r;
  }

  var str = (r &#x3e; 0) ? buffer.toString(encoding, 0, r) : &#x27;&#x27;;
  return [str, r];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var pos = 0;

    mkdirp.sync(outDir);
    read = fs.openSync(inFile, &#x27;r&#x27;);
    write = fs.openSync(outFile, &#x27;w&#x27;);

    while (bytesRead &#x3e; 0) {
        bytesRead = fs.<span class="apidocCodeKeywordSpan">readSync</span>(read, buffer, 0, BUF_LENGTH, pos);
        fs.writeSync(write, buffer, 0, bytesRead);
        pos += bytesRead;
    }

    fs.closeSync(read);
    return fs.closeSync(write);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.readdir" id="apidoc.element.jsdoc.fs.readdir">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>readdir
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdir = function (path, options, callback) {
  options = options || {};
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  }
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);

  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.readdir(pathModule._makeLong(path), options.encoding, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.readdirSync" id="apidoc.element.jsdoc.fs.readdirSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>readdirSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdirSync = function (path, options) {
  options = options || {};
  if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(path);
  return binding.readdir(pathModule._makeLong(path), options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    catch (e) {
isFile = false;
    }
    if (isFile) {
files = [dir];
    }
    else {
files = fs.<span class="apidocCodeKeywordSpan">readdirSync</span>(dir);
    }

    for (var i = 0, l = files.length; i &#x3c; l; i++) {
file = String(files[i]);

// skip dot files
if (file.match(/^\.[^\.\/\\]/)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.readlink" id="apidoc.element.jsdoc.fs.readlink">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>readlink
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlink = function (path, options, callback) {
  options = options || {};
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  }
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.readlink(pathModule._makeLong(path), options.encoding, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.readlinkSync" id="apidoc.element.jsdoc.fs.readlinkSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>readlinkSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlinkSync = function (path, options) {
  options = options || {};
  if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(path);
  return binding.readlink(pathModule._makeLong(path), options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var path = require(&#x27;path&#x27;);

    var jsdocPath = args[0];
    var pwd = args[1];

    // resolve the path if it&#x27;s a symlink
    if ( fs.statSync(jsdocPath).isSymbolicLink() ) {
        jsdocPath = path.resolve( path.dirname(jsdocPath), fs.<span class="apidocCodeKeywordSpan">readlinkSync</span>(jsdocPath) );
    }

    env.dirname = jsdocPath;
    env.pwd = pwd;
    env.args = process.argv.slice(2);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.realpath" id="apidoc.element.jsdoc.fs.realpath">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>realpath
        <span class="apidocSignatureSpan">(p, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function realpath(p, options, callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    callback = maybeCallback(options);
    options = {};
  }

  if (!options) {
    options = {};
  } else if (typeof options === &#x27;function&#x27;) {
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  } else if (typeof options !== &#x27;object&#x27;) {
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  }
  if (!nullCheck(p, callback))
    return;

  p = p.toString(&#x27;utf8&#x27;);
  p = pathModule.resolve(p);

  const seenLinks = {};
  const knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = &#x27;&#x27;;

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows &#x26;&#x26; !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return callback(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos &#x3e;= p.length) {
      return callback(null, encodeRealpathResult(p, options));
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base]) {
      return process.nextTick(LOOP);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return callback(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      return process.nextTick(LOOP);
    }

    // stat &#x26; read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    let id;
    if (!isWindows) {
      id = `${stat.dev.toString(32)}:${stat.ino.toString(32)}`;
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return callback(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return callback(err);

    var resolvedLink = pathModule.resolve(previous, target);
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.realpathSync" id="apidoc.element.jsdoc.fs.realpathSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>realpathSync
        <span class="apidocSignatureSpan">(p, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function realpathSync(p, options) {
  if (!options)
    options = {};
  else if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  else if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(p);

  p = p.toString(&#x27;utf8&#x27;);
  p = pathModule.resolve(p);

  const seenLinks = {};
  const knownHard = {};
  const cache = options[realpathCacheKey];
  const original = p;

  const maybeCachedResult = cache &#x26;&#x26; cache.get(p);
  if (maybeCachedResult) {
    return maybeCachedResult;
  }

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = &#x27;&#x27;;

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows &#x26;&#x26; !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos &#x3c; p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache &#x26;&#x26; cache.get(base) === base)) {
      continue;
    }

    var resolvedLink;
    const maybeCachedResolved = cache &#x26;&#x26; cache.get(base);
    if (maybeCachedResolved) {
      resolvedLink = maybeCachedResolved;
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache.set(base, base);
        continue;
      }

      // read the link if it wasn&#x27;t read before
      // dev/ino always return 0 on windows, so skip the check.
      let linkTarget = null;
      let id;
      if (!isWindows) {
        id = `${stat.dev.toString(32)}:${stat.ino.toString(32)}`;
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);

      if (cache) cache.set(base, resolvedLink);
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache.set(original, p);
  return encodeRealpathResult(p, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.rename" id="apidoc.element.jsdoc.fs.rename">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>rename
        <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (oldPath, newPath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(oldPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rename(pathModule._makeLong(oldPath),
                 pathModule._makeLong(newPath),
                 req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.renameSync" id="apidoc.element.jsdoc.fs.renameSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>renameSync
        <span class="apidocSignatureSpan">(oldPath, newPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renameSync = function (oldPath, newPath) {
  nullCheck(oldPath);
  nullCheck(newPath);
  return binding.rename(pathModule._makeLong(oldPath),
                        pathModule._makeLong(newPath));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.rmdir" id="apidoc.element.jsdoc.fs.rmdir">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>rmdir
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdir = function (path, callback) {
  callback = maybeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rmdir(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.rmdirSync" id="apidoc.element.jsdoc.fs.rmdirSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>rmdirSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdirSync = function (path) {
  nullCheck(path);
  return binding.rmdir(pathModule._makeLong(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.stat" id="apidoc.element.jsdoc.fs.stat">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>stat
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function (path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.stat(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.statSync" id="apidoc.element.jsdoc.fs.statSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>statSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statSync = function (path) {
  nullCheck(path);
  binding.stat(pathModule._makeLong(path), statValues);
  return statsFromValues();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cli.printHelp().then(function () {
        cli.exit(1);
    });
}

confPath = env.opts.configure || path.join(env.dirname, &#x27;conf.json&#x27;);
try {
    isFile = fs.<span class="apidocCodeKeywordSpan">statSync</span>(confPath).isFile();
}
catch (e) {
    isFile = false;
}

if ( !isFile &#x26;&#x26; !env.opts.configure ) {
    confPath = path.join(env.dirname, &#x27;conf.json.EXAMPLE&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.symlink" id="apidoc.element.jsdoc.fs.symlink">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>symlink
        <span class="apidocSignatureSpan">(target, path, type_, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlink = function (target, path, type_, callback_) {
  var type = (typeof type_ === &#x27;string&#x27; ? type_ : null);
  var callback = makeCallback(arguments[arguments.length - 1]);

  if (!nullCheck(target, callback)) return;
  if (!nullCheck(path, callback)) return;

  var req = new FSReqWrap();
  req.oncomplete = callback;

  binding.symlink(preprocessSymlinkDestination(target, type, path),
                  pathModule._makeLong(path),
                  type,
                  req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.symlinkSync" id="apidoc.element.jsdoc.fs.symlinkSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>symlinkSync
        <span class="apidocSignatureSpan">(target, path, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlinkSync = function (target, path, type) {
  type = (typeof type === &#x27;string&#x27; ? type : null);

  nullCheck(target);
  nullCheck(path);

  return binding.symlink(preprocessSymlinkDestination(target, type, path),
                         pathModule._makeLong(path),
                         type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.toDir" id="apidoc.element.jsdoc.fs.toDir">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>toDir
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDir = function (_path) {
    var isDirectory;

    _path = path.normalize(_path);

    try {
        isDirectory = fs.statSync(_path).isDirectory();
    }
    catch (e) {
        isDirectory = false;
    }

    if (isDirectory) {
       return _path;
    } else {
        return path.dirname(_path);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
fs.mkPath(outdir);

// copy the template&#x27;s static files to outdir
var fromDir = path.join(templatePath, &#x27;static&#x27;);
var staticFiles = fs.ls(fromDir, 3);

staticFiles.forEach(function(fileName) {
    var toDir = fs.<span class="apidocCodeKeywordSpan">toDir</span>( fileName.replace(fromDir, outdir) );
    fs.mkPath(toDir);
    fs.copyFileSync(fileName, toDir);
});

// copy user-specified static files to outdir
var staticFilePaths;
var staticFileFilter;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.truncate" id="apidoc.element.jsdoc.fs.truncate">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>truncate
        <span class="apidocSignatureSpan">(path, len, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncate = function (path, len, callback) {
  if (typeof path === &#x27;number&#x27;) {
    return fs.ftruncate(path, len, callback);
  }
  if (typeof len === &#x27;function&#x27;) {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  }

  callback = maybeCallback(callback);
  fs.open(path, &#x27;r+&#x27;, function(er, fd) {
    if (er) return callback(er);
    var req = new FSReqWrap();
    req.oncomplete = function oncomplete(er) {
      fs.close(fd, function(er2) {
        callback(er || er2);
      });
    };
    binding.ftruncate(fd, len, req);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.truncateSync" id="apidoc.element.jsdoc.fs.truncateSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>truncateSync
        <span class="apidocSignatureSpan">(path, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncateSync = function (path, len) {
  if (typeof path === &#x27;number&#x27;) {
    // legacy
    return fs.ftruncateSync(path, len);
  }
  if (len === undefined) {
    len = 0;
  }
  // allow error to be thrown, but still close fd.
  var fd = fs.openSync(path, &#x27;r+&#x27;);
  var ret;

  try {
    ret = fs.ftruncateSync(fd, len);
  } finally {
    fs.closeSync(fd);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.unlink" id="apidoc.element.jsdoc.fs.unlink">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>unlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.unlink(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.unlinkSync" id="apidoc.element.jsdoc.fs.unlinkSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>unlinkSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlinkSync = function (path) {
  nullCheck(path);
  return binding.unlink(pathModule._makeLong(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.unwatchFile" id="apidoc.element.jsdoc.fs.unwatchFile">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>unwatchFile
        <span class="apidocSignatureSpan">(filename, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwatchFile = function (filename, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat = statWatchers.get(filename);

  if (stat === undefined) return;

  if (typeof listener === &#x27;function&#x27;) {
    stat.removeListener(&#x27;change&#x27;, listener);
  } else {
    stat.removeAllListeners(&#x27;change&#x27;);
  }

  if (stat.listenerCount(&#x27;change&#x27;) === 0) {
    stat.stop();
    statWatchers.delete(filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.utimes" id="apidoc.element.jsdoc.fs.utimes">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>utimes
        <span class="apidocSignatureSpan">(path, atime, mtime, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimes = function (path, atime, mtime, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.utimes(pathModule._makeLong(path),
                 toUnixTimestamp(atime),
                 toUnixTimestamp(mtime),
                 req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.utimesSync" id="apidoc.element.jsdoc.fs.utimesSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>utimesSync
        <span class="apidocSignatureSpan">(path, atime, mtime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimesSync = function (path, atime, mtime) {
  nullCheck(path);
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.utimes(pathModule._makeLong(path), atime, mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.watch" id="apidoc.element.jsdoc.fs.watch">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>watch
        <span class="apidocSignatureSpan">(filename, options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (filename, options, listener) {
  nullCheck(filename);

  options = options || {};
  if (typeof options === &#x27;function&#x27;) {
    listener = options;
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  }
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);

  if (options.persistent === undefined) options.persistent = true;
  if (options.recursive === undefined) options.recursive = false;

  const watcher = new FSWatcher();
  watcher.start(filename,
                options.persistent,
                options.recursive,
                options.encoding);

  if (listener) {
    watcher.addListener(&#x27;change&#x27;, listener);
  }

  return watcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.watchFile" id="apidoc.element.jsdoc.fs.watchFile">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>watchFile
        <span class="apidocSignatureSpan">(filename, options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watchFile = function (filename, options, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat;

  var defaults = {
    // Poll interval in milliseconds. 5007 is what libev used to use. It&#x27;s
    // a little on the slow side but let&#x27;s stick with it for now to keep
    // behavioral changes to a minimum.
    interval: 5007,
    persistent: true
  };

  if (options !== null &#x26;&#x26; typeof options === &#x27;object&#x27;) {
    options = util._extend(defaults, options);
  } else {
    listener = options;
    options = defaults;
  }

  if (typeof listener !== &#x27;function&#x27;) {
    throw new Error(&#x27;&#x22;watchFile()&#x22; requires a listener function&#x27;);
  }

  stat = statWatchers.get(filename);

  if (stat === undefined) {
    stat = new StatWatcher();
    stat.start(filename, options.persistent, options.interval);
    statWatchers.set(filename, stat);
  }

  stat.addListener(&#x27;change&#x27;, listener);
  return stat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.write" id="apidoc.element.jsdoc.fs.write">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>write
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (fd, buffer, offset, length, position, callback) {
  function wrapper(err, written) {
    // Retain a reference to buffer so that it can&#x27;t be GC&#x27;ed too soon.
    callback(err, written || 0, buffer);
  }

  var req = new FSReqWrap();
  req.oncomplete = wrapper;

  if (buffer instanceof Buffer) {
    // if no position is passed then assume null
    if (typeof position === &#x27;function&#x27;) {
      callback = position;
      position = null;
    }
    callback = maybeCallback(callback);
    return binding.writeBuffer(fd, buffer, offset, length, position, req);
  }

  if (typeof buffer !== &#x27;string&#x27;)
    buffer += &#x27;&#x27;;
  if (typeof position !== &#x27;function&#x27;) {
    if (typeof offset === &#x27;function&#x27;) {
      position = offset;
      offset = null;
    } else {
      position = length;
    }
    length = &#x27;utf8&#x27;;
  }
  callback = maybeCallback(position);
  return binding.writeString(fd, buffer, offset, length, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
}

// Print a message to STDOUT without a terminating newline.
function printToStdout() {
   var args = Array.prototype.slice.call(arguments, 0);

   process.stdout.<span class="apidocCodeKeywordSpan">write</span>( util.format.apply(util, args) );
}

/**
* Log a message at log level {@link module:jsdoc/util/logger.LEVELS.DEBUG}.
*
* @alias module:jsdoc/util/logger.debug
* @param {string} message - The message to log.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.writeFile" id="apidoc.element.jsdoc.fs.writeFile">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>writeFile
        <span class="apidocSignatureSpan">(path, data, options, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);

  if (!options || typeof options === &#x27;function&#x27;) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  assertEncoding(options.encoding);

  var flag = options.flag || &#x27;w&#x27;;

  if (isFd(path)) {
    writeFd(path, true);
    return;
  }

  fs.open(path, flag, options.mode, function(openErr, fd) {
    if (openErr) {
      callback(openErr);
    } else {
      writeFd(fd, false);
    }
  });

  function writeFd(fd, isUserFd) {
    var buffer = (data instanceof Buffer) ?
        data : Buffer.from(&#x27;&#x27; + data, options.encoding || &#x27;utf8&#x27;);
    var position = /a/.test(flag) ? null : 0;

    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.writeFileSync" id="apidoc.element.jsdoc.fs.writeFileSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>writeFileSync
        <span class="apidocSignatureSpan">(path, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFileSync = function (path, data, options) {
  if (!options) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  assertEncoding(options.encoding);

  var flag = options.flag || &#x27;w&#x27;;
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);

  if (!(data instanceof Buffer)) {
    data = Buffer.from(&#x27;&#x27; + data, options.encoding || &#x27;utf8&#x27;);
  }
  var offset = 0;
  var length = data.length;
  var position = /a/.test(flag) ? null : 0;
  try {
    while (length &#x3e; 0) {
      var written = fs.writeSync(fd, data, offset, length, position);
      offset += written;
      length -= written;
      if (position !== null) {
        position += written;
      }
    }
  } finally {
    if (!isUserFd) fs.closeSync(fd);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var outpath = path.join(outdir, filename),
    html = view.render(&#x27;container.tmpl&#x27;, docData);

if (resolveLinks) {
    html = helper.resolveLinks(html); // turn {@link foo} into &#x3c;a href=&#x22;foodoc.html&#x22;&#x3e;foo&#x3c;/a&#x3e;
}

fs.<span class="apidocCodeKeywordSpan">writeFileSync</span>(outpath, html, &#x27;utf8&#x27;);
}

function generateSourceFiles(sourceFiles, encoding) {
encoding = encoding || &#x27;utf8&#x27;;
Object.keys(sourceFiles).forEach(function(file) {
    var source;
    // links are keyed to the shortened path in each doclet&#x27;s `meta.shortpath` property
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.fs.writeSync" id="apidoc.element.jsdoc.fs.writeSync">
        function <span class="apidocSignatureSpan">jsdoc.fs.</span>writeSync
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeSync = function (fd, buffer, offset, length, position) {
  if (buffer instanceof Buffer) {
    if (position === undefined)
      position = null;
    return binding.writeBuffer(fd, buffer, offset, length, position);
  }
  if (typeof buffer !== &#x27;string&#x27;)
    buffer += &#x27;&#x27;;
  if (offset === undefined)
    offset = null;
  return binding.writeString(fd, buffer, offset, length, position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    mkdirp.sync(outDir);
    read = fs.openSync(inFile, &#x27;r&#x27;);
    write = fs.openSync(outFile, &#x27;w&#x27;);

    while (bytesRead &#x3e; 0) {
        bytesRead = fs.readSync(read, buffer, 0, BUF_LENGTH, pos);
        fs.<span class="apidocCodeKeywordSpan">writeSync</span>(write, buffer, 0, bytesRead);
        pos += bytesRead;
    }

    fs.closeSync(read);
    return fs.closeSync(write);
};
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.inline" id="apidoc.module.jsdoc.inline">module jsdoc.inline</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.inline.extractInlineTag" id="apidoc.element.jsdoc.inline.extractInlineTag">
        function <span class="apidocSignatureSpan">jsdoc.inline.</span>extractInlineTag
        <span class="apidocSignatureSpan">(string, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractInlineTag = function (string, tag) {
    return exports.replaceInlineTag(string, tag, function(str, tagInfo) {
        return str.replace(tagInfo.completeTag, &#x27;&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    nameAndDescription = jsdoc.name.splitName(text);
    name = nameAndDescription.name;
    text = nameAndDescription.description;
}

// an inline @type tag, like {@type Foo}, overrides the type expression
if (canHaveType) {
    typeOverride = jsdoc.tag.inline.<span class="apidocCodeKeywordSpan">extractInlineTag</span>(text, &#x27;type&#x27;);
    if (typeOverride.tags &#x26;&#x26; typeOverride.tags[0]) {
        typeExpression = typeOverride.tags[0].text;
    }
    text = typeOverride.newString;
}

return {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.inline.isInlineTag" id="apidoc.element.jsdoc.inline.isInlineTag">
        function <span class="apidocSignatureSpan">jsdoc.inline.</span>isInlineTag
        <span class="apidocSignatureSpan">(string, tagName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInlineTag = function (string, tagName) {
    return regExpFactory(tagName, &#x27;^&#x27;, &#x27;$&#x27;).test(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.inline.replaceInlineTag" id="apidoc.element.jsdoc.inline.replaceInlineTag">
        function <span class="apidocSignatureSpan">jsdoc.inline.</span>replaceInlineTag
        <span class="apidocSignatureSpan">(string, tag, replacer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceInlineTag = function (string, tag, replacer) {
    var replacers = {};
    replacers[tag] = replacer;

    return exports.replaceInlineTags(string, replacers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} string - The string from which to extract text.
 * @param {?string} tag - The inline tag to extract.
 * @return {module:jsdoc/tag/inline.InlineTagResult} The updated string, as well as information
 * about the inline tags that were found.
 */
exports.extractInlineTag = function(string, tag) {
    return exports.<span class="apidocCodeKeywordSpan">replaceInlineTag</span>(string, tag, function(str, tagInfo) {
        return str.replace(tagInfo.completeTag, &#x27;&#x27;);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.inline.replaceInlineTags" id="apidoc.element.jsdoc.inline.replaceInlineTags">
        function <span class="apidocSignatureSpan">jsdoc.inline.</span>replaceInlineTags
        <span class="apidocSignatureSpan">(string, replacers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceInlineTags = function (string, replacers) {
    var tagInfo = [];

    function replaceMatch(replacer, tag, match, text) {
        var matchedTag = {
            completeTag: match,
            tag: tag,
            text: text
        };
        tagInfo.push(matchedTag);

        return replacer(string, matchedTag);
    }

    string = string || &#x27;&#x27;;

    Object.keys(replacers).forEach(function(replacer) {
        var tagRegExp = regExpFactory(replacer);
        var matches;
        var previousString;

        // call the replacer once for each match
        do {
            matches = tagRegExp.exec(string);
            if (matches) {
                previousString = string;
                string = replaceMatch(replacers[replacer], replacer, matches[0], matches[1]);
            }
        } while (matches &#x26;&#x26; previousString !== string);
    });

    return {
        tags: tagInfo,
        newString: string.trim()
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return {module:jsdoc/tag/inline.InlineTagResult} The updated string, as well as information
* about the inline tags that were found.
*/
exports.replaceInlineTag = function(string, tag, replacer) {
   var replacers = {};
   replacers[tag] = replacer;

   return exports.<span class="apidocCodeKeywordSpan">replaceInlineTags</span>(string, replacers);
};

/**
* Extract inline tags from a string, replacing them with an empty string.
*
* @param {string} string - The string from which to extract text.
* @param {?string} tag - The inline tag to extract.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.logger" id="apidoc.module.jsdoc.logger">module jsdoc.logger</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.logger.debug" id="apidoc.element.jsdoc.logger.debug">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debug = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
logger.once(&#x27;logger:fatal&#x27;, fatalError);

return cli;
};

// TODO: docs
cli.logStart = function() {
logger.<span class="apidocCodeKeywordSpan">debug</span>( cli.getVersion() );

logger.debug(&#x27;Environment info: %j&#x27;, {
    env: {
        conf: env.conf,
        opts: env.opts
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.error" id="apidoc.element.jsdoc.logger.error">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    encoding: &#x27;utf8&#x27;
};

try {
    env.opts = args.parse(env.args);
}
catch (e) {
    console.<span class="apidocCodeKeywordSpan">error</span>(e.message + &#x27;\n&#x27;);
    cli.printHelp().then(function () {
        cli.exit(1);
    });
}

confPath = env.opts.configure || path.join(env.dirname, &#x27;conf.json&#x27;);
try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.fatal" id="apidoc.element.jsdoc.logger.fatal">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>fatal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fatal = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return templatePath || env.opts.template;
})();

try {
    template = require(env.opts.template + &#x27;/publish&#x27;);
}
catch (e) {
    logger.<span class="apidocCodeKeywordSpan">fatal</span>(&#x27;Unable to load template: &#x27; + e.message || e);
}

// templates should include a publish.js file that exports a &#x22;publish&#x22; function
if (template.publish &#x26;&#x26; typeof template.publish === &#x27;function&#x27;) {
    logger.info(&#x27;Generating output files...&#x27;);
    var publishPromise = template.publish(
        taffy(props.docs),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.getLevel" id="apidoc.element.jsdoc.logger.getLevel">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>getLevel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLevel() {
    return logLevel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.info" id="apidoc.element.jsdoc.logger.info">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>info
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (env.run.finish &#x26;&#x26; env.run.start) {
    delta = env.run.finish.getTime() - env.run.start.getTime();
}

if (delta !== undefined) {
    deltaSeconds = (delta / 1000).toFixed(2);
    logger.<span class="apidocCodeKeywordSpan">info</span>(&#x27;Finished running in %s seconds.&#x27;, deltaSeconds);
}
};

// TODO: docs
cli.runCommand = function(cb) {
var cmd;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.printDebug" id="apidoc.element.jsdoc.logger.printDebug">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>printDebug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printDebug = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.printInfo" id="apidoc.element.jsdoc.logger.printInfo">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>printInfo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printInfo = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.printVerbose" id="apidoc.element.jsdoc.logger.printVerbose">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>printVerbose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printVerbose = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.setLevel" id="apidoc.element.jsdoc.logger.setLevel">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>setLevel
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLevel(level) {
    logLevel = (level !== undefined) ? level : DEFAULT_LEVEL;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function fatalError() {
    cli.exit(1);
}

if (env.opts.debug) {
    logger.<span class="apidocCodeKeywordSpan">setLevel</span>(logger.LEVELS.DEBUG);
}
else if (env.opts.verbose) {
    logger.setLevel(logger.LEVELS.INFO);
}

if (env.opts.pedantic) {
    logger.once(&#x27;logger:warn&#x27;, recoverableError);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.verbose" id="apidoc.element.jsdoc.logger.verbose">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>verbose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verbose = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.logger.warn" id="apidoc.element.jsdoc.logger.warn">
        function <span class="apidocSignatureSpan">jsdoc.logger.</span>warn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function () {
    var loggerArgs;

    var args = Array.prototype.slice.call(arguments, 0);

    if (logLevel &#x3e;= level) {
        loggerArgs = addPrefix(args, prefix);
        func.apply(null, loggerArgs);
    }

    args.unshift(eventName);
    logger.emit.apply(logger, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // check for errors that make the tag useless
    if (!tag.text &#x26;&#x26; tagDef.mustHaveValue) {
        logger.error( buildMessage(tag.title, meta, &#x27;requires a value&#x27;) );
    }

    // check for minor issues that are usually harmless
    else if (tag.text &#x26;&#x26; tagDef.mustNotHaveValue) {
        logger.<span class="apidocCodeKeywordSpan">warn</span>( buildMessage(tag.title, meta,
            &#x27;does not permit a value; the value will be ignored&#x27;) );
    }
    else if (tag.value &#x26;&#x26; tag.value.description &#x26;&#x26; tagDef.mustNotHaveDescription) {
        logger.warn( buildMessage(tag.title, meta,
            &#x27;does not permit a description; the description will be ignored&#x27;) );
    }
};
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.name" id="apidoc.module.jsdoc.name">module jsdoc.name</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.name.applyNamespace" id="apidoc.element.jsdoc.name.applyNamespace">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>applyNamespace
        <span class="apidocSignatureSpan">(longname, ns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyNamespace = function (longname, ns) {
    var nameParts = exports.shorten(longname);
    var name = nameParts.name;

    longname = nameParts.longname;

    if ( !/^[a-zA-Z]+?:.+$/i.test(name) ) {
        longname = longname.replace( new RegExp(escape(name) + &#x27;$&#x27;), ns + &#x27;:&#x27; + name );
    }

    return longname;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Doclet.prototype.setLongname = function(name) {
   /**
    * The fully resolved symbol name.
    * @type {string}
    */
   this.longname = removeGlobal(name);
   if (jsdoc.tag.dictionary.isNamespace(this.kind)) {
       this.longname = jsdoc.name.<span class="apidocCodeKeywordSpan">applyNamespace</span>(this.longname, this.kind);
   }
};

/**
* Get the full path to the source file that is associated with a doclet.
*
* @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.combine" id="apidoc.element.jsdoc.name.combine">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>combine
        <span class="apidocSignatureSpan">(parts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combine = function (parts) {
    return [
        (parts.memberof || &#x27;&#x27;),
        (parts.scope || &#x27;&#x27;),
        (parts.name || &#x27;&#x27;),
        (parts.variation || &#x27;&#x27;)
    ].join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function reparentDoclet(parent, child) {
    var parts = name.shorten(child.longname);

    parts.memberof = parent.longname;
    child.memberof = parent.longname;
    child.longname = name.<span class="apidocCodeKeywordSpan">combine</span>(parts);
}

function parentIsClass(parent) {
    return parent.kind === &#x27;class&#x27;;
}

function staticToInstance(doclet) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.hasAncestor" id="apidoc.element.jsdoc.name.hasAncestor">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>hasAncestor
        <span class="apidocSignatureSpan">(parent, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasAncestor = function (parent, child) {
    var hasAncestor = false;
    var memberof = child;

    if (!parent || !child) {
        return hasAncestor;
    }

    // fast path for obvious non-ancestors
    if (child.indexOf(parent) !== 0) {
        return hasAncestor;
    }

    do {
        memberof = exports.shorten(memberof).memberof;

        if (memberof === parent) {
            hasAncestor = true;
        }
    } while (!hasAncestor &#x26;&#x26; memberof);

    return hasAncestor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.longnamesToTree" id="apidoc.element.jsdoc.name.longnamesToTree">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>longnamesToTree
        <span class="apidocSignatureSpan">(longnames, doclets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function longnamesToTree(longnames, doclets) {
    var splitOptions = { includeVariation: false };
    var tree = {};

    longnames.forEach(function(longname) {
        var currentLongname = &#x27;&#x27;;
        var currentParent = tree;
        var nameInfo;
        var processed;

        // don&#x27;t try to add empty longnames to the tree
        if (!longname) {
            return;
        }

        processed = splitLongname(longname, splitOptions);
        nameInfo = processed.nameInfo;

        processed.chunks.forEach(function(chunk) {
            currentLongname += chunk;

            if (currentParent !== tree) {
                currentParent.children = currentParent.children || {};
                currentParent = currentParent.children;
            }

            if (!hasOwnProp.call(currentParent, chunk)) {
                currentParent[chunk] = nameInfo[currentLongname];
            }

            if (currentParent[chunk]) {
                currentParent[chunk].doclet = doclets ? doclets[currentLongname] : null;
                currentParent = currentParent[chunk];
            }
        });
    });

    return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.resolve" id="apidoc.element.jsdoc.name.resolve">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>resolve
        <span class="apidocSignatureSpan">(doclet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (doclet) {
    var about = {};
    var memberof = doclet.memberof || &#x27;&#x27;;
    var metaName;
    var name = doclet.name ? String(doclet.name) : &#x27;&#x27;;
    var parentDoc;
    var puncAndName;
    var puncAndNameIndex;

    // change MyClass.prototype.instanceMethod to MyClass#instanceMethod
    // (but not in function params, which lack doclet.kind)
    // TODO: check for specific doclet.kind values (probably function, class, and module)
    if (name &#x26;&#x26; doclet.kind) {
        name = prototypeToPunc(name);
    }
    doclet.name = name;

    // member of a var in an outer scope?
    if (name &#x26;&#x26; !memberof &#x26;&#x26; doclet.meta.code &#x26;&#x26; doclet.meta.code.funcscope) {
        name = doclet.longname = doclet.meta.code.funcscope + SCOPE.PUNC.INNER + name;
    }

    if (memberof || doclet.forceMemberof) { // @memberof tag given
        memberof = prototypeToPunc(memberof);

        // the name is a complete longname, like @name foo.bar, @memberof foo
        if (name &#x26;&#x26; nameIsLongname(name, memberof) &#x26;&#x26; name !== memberof) {
            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));
        }
        // the name and memberof are identical and refer to a module,
        // like @name module:foo, @memberof module:foo (probably a member like &#x27;var exports&#x27;)
        else if (name &#x26;&#x26; name === memberof &#x26;&#x26; name.indexOf(MODULE_NAMESPACE) === 0) {
            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));
        }
        // the name and memberof are identical, like @name foo, @memberof foo
        else if (name &#x26;&#x26; name === memberof) {
            doclet.scope = doclet.scope || DEFAULT_SCOPE;
            name = memberof + scopeToPunc[doclet.scope] + name;
            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));
        }
        // like @memberof foo# or @memberof foo~
        else if (name &#x26;&#x26; REGEXP_TRAILING_SCOPE.test(memberof) ) {
            about = exports.shorten(memberof + name, (doclet.forceMemberof ? memberof : undefined));
        }
        else if (name &#x26;&#x26; doclet.scope) {
            about = exports.shorten(memberof + (scopeToPunc[doclet.scope] || &#x27;&#x27;) + name,
                (doclet.forceMemberof ? memberof : undefined));
        }
    }
    else { // no @memberof
        about = exports.shorten(name);
    }

    if (about.name) {
        doclet.name = about.name;
    }

    if (about.memberof) {
        doclet.setMemberof(about.memberof);
    }

    if (about.longname &#x26;&#x26; (!doclet.longname || doclet.longname === doclet.name)) {
        doclet.setLongname(about.longname);
    }

    if (doclet.scope === SCOPE.NAMES.GLOBAL) { // via @global tag?
        doclet.setLongname(doclet.name);
        delete doclet.memberof;
    }
    else if (about.scope) {
        if (about.memberof === LONGNAMES.GLOBAL) { // via @memberof &#x3c;global&#x3e; ?
            doclet.scope = SCOPE.NAMES.GLOBAL;
        }
        else {
            doclet.scope = puncToScope[about.scope];
        }
    }
    else if (doclet.name &#x26;&#x26; doclet.memberof &#x26;&#x26; !doclet.longname) {
        if ( REGEXP_LEADING_SCOPE.test(doclet.name) ) {
            doclet.scope = puncToScope[RegExp.$1];
            doclet.name = doclet.name.substr(1);
        }
        else if (doclet.meta.code &#x26;&#x26; doclet.meta.code.name) {
            // HACK: Handle cases where an ES 2015 class is a static memberof something else, and
            // the class has instance members. In these cases, we have to detect the instance
            // members&#x27; scope by looking at the meta info. There&#x27;s almost certainly a better way to
            // do this...
            metaName = String(doclet.meta.code.name);
            puncAndName = SCOPE.PUNC.INSTANCE + doclet.name;
            puncAndNameIndex = metaName.indexOf(puncAndName);
            if ( puncAndNameIndex !== -1 &#x26;&#x26;
                (puncAndNameIndex === metaName.length - puncAndName.length) ) {
                doclet.scope = SCOPE.NAMES.INSTANCE;
            }
        }

        doclet.scope = doclet.scope || DEFAULT_SCOPE;
        doclet.setLongname(doclet.memberof + scope ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// TODO: docs
cli.printHelp = function() {
cli.printVersion();
console.log( &#x27;\n&#x27; + require(&#x27;jsdoc/opts/args&#x27;).help() + &#x27;\n&#x27; );
console.log(&#x27;Visit http://usejsdoc.org for more information.&#x27;);
return Promise.<span class="apidocCodeKeywordSpan">resolve</span>(0);
};

// TODO: docs
cli.runTests = function() {
var path = require(&#x27;jsdoc/path&#x27;);

var runner = Promise.promisify(require( path.join(env.dirname, &#x27;test/runner&#x27;) ));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.shorten" id="apidoc.element.jsdoc.name.shorten">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>shorten
        <span class="apidocSignatureSpan">(longname, forcedMemberof)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shorten = function (longname, forcedMemberof) {
    return atomize(longname, SCOPE_PUNC, forcedMemberof);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function addDocletProperty(doclets, propName, value) {
    for (var i = 0, l = doclets.length; i &#x3c; l; i++) {
        doclets[i][propName] = value;
    }
}

function reparentDoclet(parent, child) {
    var parts = name.<span class="apidocCodeKeywordSpan">shorten</span>(child.longname);

    parts.memberof = parent.longname;
    child.memberof = parent.longname;
    child.longname = name.combine(parts);
}

function parentIsClass(parent) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.splitName" id="apidoc.element.jsdoc.name.splitName">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>splitName
        <span class="apidocSignatureSpan">(nameDesc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splitName = function (nameDesc) {
    // like: name, [name], name text, [name] text, name - text, or [name] - text
    // the hyphen must be on the same line as the name; this prevents us from treating a Markdown
    // dash as a separator

    // optional values get special treatment
    var result = null;
    if (nameDesc[0] === &#x27;[&#x27;) {
        result = splitNameMatchingBrackets(nameDesc);
        if (result !== null) {
            return result;
        }
    }

    nameDesc.match(REGEXP_NAME_DESCRIPTION);
    return {
        name: RegExp.$1,
        description: RegExp.$2
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (canHaveType) {
    expressionAndText = extractTypeExpression(text);
    typeExpression = expressionAndText.expression;
    text = expressionAndText.newString;
}

if (canHaveName) {
    nameAndDescription = jsdoc.name.<span class="apidocCodeKeywordSpan">splitName</span>(text);
    name = nameAndDescription.name;
    text = nameAndDescription.description;
}

// an inline @type tag, like {@type Foo}, overrides the type expression
if (canHaveType) {
    typeOverride = jsdoc.tag.inline.extractInlineTag(text, &#x27;type&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.stripNamespace" id="apidoc.element.jsdoc.name.stripNamespace">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>stripNamespace
        <span class="apidocSignatureSpan">(longname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripNamespace = function (longname) {
    return longname.replace(/^[a-zA-Z]+:/, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsdoc.name.stripVariation" id="apidoc.element.jsdoc.name.stripVariation">
        function <span class="apidocSignatureSpan">jsdoc.name.</span>stripVariation
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripVariation = function (name) {
    var parts = exports.shorten(name);

    parts.variation = &#x27;&#x27;;

    return exports.combine(parts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = _.defaults(options || {}, {
    includeVariation: true
});

do {
    if (!options.includeVariation) {
        previousName = exports.<span class="apidocCodeKeywordSpan">stripVariation</span>(previousName);
    }
    currentNameInfo = nameInfo[previousName] = atomize(previousName, splitters);
    previousName = currentNameInfo.memberof;
    chunks.push(currentNameInfo.scope + currentNameInfo.name);
} while (previousName);

return {
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsdoc.publish" id="apidoc.module.jsdoc.publish">module jsdoc.publish</a></h1>


    <h2>
        <a href="#apidoc.element.jsdoc.publish.publish" id="apidoc.element.jsdoc.publish.publish">
        function <span class="apidocSignatureSpan">jsdoc.</span>publish
        <span class="apidocSignatureSpan">(data, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (data, opts) {
    var root = {},
        docs;

    data({undocumented: true}).remove();
    docs = data().get(); // &#x3c;-- an array of Doclet objects

    graft(root, docs);

    if (opts.destination === &#x27;console&#x27;) {
        if (opts.query &#x26;&#x26; opts.query.format === &#x27;xml&#x27;) {
            var xml = require(&#x27;js2xmlparser&#x27;);
            console.log( xml(&#x27;jsdoc&#x27;, root) );
        }
        else {
            console.log( require(&#x27;jsdoc/util/dumper&#x27;).dump(root) );
        }
    }
    else {
        console.log(&#x27;This template only supports output to the console. Use the option &#x22;-d console&#x22; when you run JSDoc.&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
catch (e) {
    logger.fatal(&#x27;Unable to load template: &#x27; + e.message || e);
}

// templates should include a publish.js file that exports a &#x22;publish&#x22; function
if (template.publish &#x26;&#x26; typeof template.publish === &#x27;function&#x27;) {
    logger.info(&#x27;Generating output files...&#x27;);
    var publishPromise = template.<span class="apidocCodeKeywordSpan">publish</span>(
        taffy(props.docs),
        env.opts,
        resolver.root
    );

    return Promise.resolve(publishPromise);
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
